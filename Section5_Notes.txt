# The Question-Answer App

## Lesson 49) Demo

The app we'll be making allows users to ask questions and allows promoted experts to answer asked questions.
A logged in user can ask questions directed to experts, and when that expert logs in they can see all the questions that
were directed to them.
Once they answer the question, that question will be shown on the home screen with a list of other questions and when you 
click on a question, you can view the answer to the question.
There are multiple roles in the app, as well as log in and log out functionalities.

## Lesson 50) Overview of Templates:

We'll start by looking through the template files provided to start this project.
There are 8 template files that'll comprise the parts of the app that a user will be able to go to.
We have the home template with a list of questions already answered by an expert.
Then registration page for users to register to the app.
A log in page for registered users to log in.
The Ask a Question template page, lets you type in a question and select an expert to ask, then submit.
The Answer page for experts to answer questions directed to them.
The Question template page to view a question and answer and relevant details.
An unanswered questions page for an expert to view all the unanswered questions directed at them.
Lastly, there's a User List page wherein an admin can manage the users and experts in the page.

## Lesson 51) Install and Templates

This lesson covers all the up front initializations done for this lesson.
Including the app.py, virtual environment setup first, including installing flask.
We'll then download the html and css files from the lesson resources and move them into the templates and static folders appropriately.
We'll now go ahead and set up our base routes to work with for the various pages going forward.
For now each route function will be a pass, as we're just looking to initialize each route first.
In total, we'll have created 8 routes.
Having set up the routes we can now configure the routes to return the relevant template for each one.
Having set up the render_templates for each route we'll do a test run of the app, and upon loading the pages up we can see the styling
is incorrect, which implies the css files are not linked to the html files.
So next we'll go to each of the templates and update the static files to reference the styling correctly.
Remember to use url_for to reference the stylesheets.
Having done this we'll re-run the app to test a page and confirm the stylesheets are being referenced correctly.
Note that there are 3 css files supplied in the course resources, the one named "bootstrap-theme" isn't used, and would
otherwise be deleted, but in this case will be kept.

## Lesson 52) Database Helpers

Before actually creating the database we'll be using for this app, we'll create the database helper functions for 
accessing the database (connect_db and get_db).
These are being stored in a separate file named database.py and we'll then import get_db in the app (as it's the only function we directly call)
Once the database has been created we'll get the path to the database and add it in the connect_db function.
Lastly, we'll add the @app.teardown decorator to automatically close any open connection to the database upon route commpletion.

## Lesson 53) Creating the Database:

We'll now be creating the actual database, and to do this, we'll first create the schema, in a file called schema.sql.
Our data model will simply have 2 tables, users and questions.
We could make the data model more complex, but it's entirely unnecessary so we'll keep it simple as is.
Note that in the questions table, the answer_text field we're creating is allowed to be null as a question cannot have an answer upon creation.
All other data points are not null.
We could also make use of foreign keys, but again it's not necessary given the data model.
Having done this we'll now go ahead and get our database created by executing the schema.
    "cat schema.sql | sqlite3 questions.db"
That should successfully create the database, then from there we go in and confirm the tables are there alongside being able to query the tables, 
even though nothing is returned.

## Lesson 54) Register User:

We'll now set up the register user route so we can register users into the database.
Firstly, in the register page template, we'll give the form a method and action, namely post and to call itself.
Next we'll change the names of the inputs as the form inputs get submitted by name and not id.
Having done this we'll now test if the submit works before continuing, which we'll check the request type to determine the output.
We'll also include logic to capture the name and password from the form to ensure that those values are being passed in the post request as well.
Having confirmed that the form is submitting, we'll now go ahead and write the code to register the user into the database.
We'll now need to import a library to allow for password hashing, which is basicaly taking a certain password and converting
it into a form that cannot be used to convert back to the original.
So you hash the password to get a long string of characters and then every time someone logs in, you hash the entered password 
and compare it to the originally hashed password to see if it's a match.
If they match, the user is logged in, if not, prompt the user to re-enter their password.
This is done because if the database is broken into for some reason, there won't be plaintext passwords that are easy to steal.
Note that password hashing doesn't mean you're 100% secure, nothing is completely secure, but it's better than not having it.
To handle the hashing, we'll import from a library called werkzeug which is what flask is built ontop of, so no installation is required.
From werkzeug we'll be importing 2 security functions:
    "from werkzeug.security import generate_password_hash, check_password_hash"
So now we'll get going with inserting the data to the database.
We'll get the db connection and write the insert query to execute.
When inserting the password into the database, we'll hash it using the generate_password_hash function.
    "hashed_password = generate_password_hash(password, method="pbkdf2")"
Note when generating a password hash, we have to provide the string we're hashing as well as the hashing method, which 
in this case is "pbkdf2".
###Note that in the video, "sha256" is used, but this is deprecated so we'll use the listed method.
A new user will be assigned the lowest accessibility tier, so expert and admin will be 0.
Expert will be obtained by getting promoted by the admin in the users screen, and the admin rights are gained through backend access 
into the database.
We'll then commit the data to the database.
Finally, we'll change the return statement to reflect "User created".
We'll now go ahead and attempt to create a user.
Note that we also needed to go back to the connect_db function to include the path to our database.
